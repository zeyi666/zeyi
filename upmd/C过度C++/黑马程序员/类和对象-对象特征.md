	C++面向对象的三大特性：封装、继承、多态
	设计一个类 要设计它的属性和行为
	- 创建类
```
		Class Cricle
		{
			public: // 访问权限
				int m_r;
			double cal {
				reuturn 2 * PI * m_r;
			}
		}
		Circle c1; // 实例化一个对象
```
	- 初始化列表
```
		Class Person {
			public:
				Person(int a, int b, int c) : M_A,M_B,M_C 
				{
					
				}
				int M_A;
				int M_B;
				int M_C;
		}
		Person p(10,15,7);
```
	- 用类对象作为类成员
```
		#include <iostream>
		using namespace std;
		class nianl{
		public:
			nianl (int a) : year(a)
			{
				cout << "年龄的构造函数被调用了" << endl;
			}
			int year;
		}; 
		
		class Person {
		
		public:
			Person(int a, int b, int c, int d) : M_A(a),M_B(b),M_C(c),nial(d)
			{	
				cout << "构造函数被调用了\n";
			}
			
			int M_A;
			int M_B;
			int M_C; 
			nianl nial;
		};
		
		int main() {
			Person p(10,15,7,17);
			cout << p.M_A << endl;
			cout << p.M_B << endl;
			cout << p.M_C << endl;
			cout << "年龄为：" << p.nial.year;
			return 0;
		} 
```
	- 静态成员
		静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员
		静态成员分为
			静态成员变量
				- 所有对象共享同一份数据
				- 在编译阶段分配内存
				- 类内声明 类外初始化
```
				class Person
				{
					public:
						static int m_A;
				};
				int Person::m_A = 100;
```
					A::member表示类A中的成员变量member
			静态成员函数
				- 所有对象共享同一个函数
				- 静态成员函数只能访问静态成员变量
			静态成员变量的访问
				1、通过对象进行访问
```
					int Person::m_A = 100;
					Person p;
					cout << p.m_A << endl;
```
				2、通过类名进行访问
```
					cout << Person::m_A;
```
			静态成员函数的访问
				1、通过对象访问
```
					Person p;
					p.func();
```
				2、通过类名访问
```
					Person::func();
```

---
```
			#include <iostream>
			using namespace std;
			
			class Person {
				public:
					static int abc;
					int abb;
					
					static void func() {
						
						abc = 7;
						abb = 9;  // 错误写法 函数不知道是哪个类的abb 
						
						cout << "func函数调用" << endl;
					}
			};
			
			int Person::abc = 10;
			
			int main() {
				Person p;
				cout << p.abc << endl;
				cout << Person::abc << endl;
				return 0;
			} 
```
	- C++对象模型和this指针
		对象模型
			成员变量和成员函数分开储存
			空对象占用的内存空间为1个字节
			成员变量 和 成员函数是分开存储的
			类的字节占用大小＝所有非静态成员变量之和 （会对齐占用最大的）
		this指针概念
		我们知道在C++中成员变量和成员函数是分开存储的
		每一个非静态成员函数只会诞生一份函数实例 也就是说多个同类型的对象会共用一块代码
		C++通过提供特殊的对象指针 this指针 解决代码是如何区分哪个对象调用的自己 this指针指向被调用的成员函数的所属对象
		this指针是隐含每一个非静态成员函数内的一种指针
		this指针不需要定义 直接使用即可
		this指针的用途
			- 当形参和成员变量同名时 可用this指针来区分
			- 在类的非静态成员函数中
		存在命名冲突 this指针区分 “形参” 和 “成员变量”
```
			#include <iostream>  
			using namespace std;  
			  
			class Person {  
			public:  
			    Person(int age) {  
			        this->age = age;  
			        ega = age;  
			    }  
			    int age;  
			    int ega;  
			};  
			  
			int main() {  
			    Person p1(17);  
			    cout << p1.age << endl;  
			  
			    Person p2(18);  
			    cout << p2.age << endl;  
			  
			    Person p3(19);  
			    cout << p1.ega << endl;  
			    cout << p3.ega << endl;  
			  
			    return 0;  
			}
```
		返回对象本身用 *this
```
		Person& PersonAddAge(Person &p)  
		{  
		    this->age += p.age;  
		    // this指向p2的指针 而*this指向的就是p2这个对象本体  
		    return *this;  
		}
		
		void test() {
			Person p1(10);
			person p2(10);
			
			//链式编程思想
			p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);
			// << 符号也属于链式编程思想 << 表示追加
			cout << "p2的年龄为:" << p2.age << endl;
			
			return;
		}
```

---
```
	#include <iostream>  
	using namespace std;  
	  
	class Person {  
	public:
		// 定义Person的析构函数  
	    Person(int age) {  
		    // 为自身的age赋值
	        this->age = age;  
	    }  
	    // 定义一个返回值为Person这个类的函数
	    // Person &表示返回值是Person的引用
	    // 如果不使用 & 表示的是返回对象的副本 会生成一个新对象
		    // 相当于 Person p add() {} // 类似这样创建新对象
		// 使用了&表示返回值是引用于Person本身 不会产生新对象
	    // const Person &p 表示接收的参数为只读的Person类的引用
	    Person &addPerson(const Person &p) {  
		    // 用当前自身的类的age加上接收的age
	        this->age += p.age;  
	        // 返回值是指向自身类的对象本身 this是本身 用*解引用
	        // 因为this是就是指向自身的指针 如果不使用*那么返回的就是指针
	        return *this;  
	    }  
	    int age;  
	};  
	  
	int main() {  
	    Person p1(10);  
	    Person p2(5);  
	  
	    p2.addPerson(p1).addPerson(p1);  
	  
	    cout << p2.age;  
	    return 0;  
	}
```
	空指针访问成员函数
```
	class Person 
	{
		void showPerson() {
			// this是指向自身的指针 这里写判断可以防止空指针
			if (this == NULL)
				return;
			cout << m_Age << endl;
		}
		int m_Age;
	};
	
	void test() 
	{
		// 定义的是空指针 没有指向的对象
		Person *p = NULL;
		p->showPerson();
	}
```
	const修饰成员函数
		常函数：
			- 成员函数后加const后我们称为这个函数为常函数
			- 常函数内不可以修改成员属性
			- 成员属性声明时加关键字mutable后 在常函数中依然可以修改
		常对象：
			- 声明对象前加const称该对象为常对象
			- 常对象只能调用常函数
```
	// 常函数  
	class Person {  
	public:  
	    // this指针的本质 是指针常量 指针的指向是不可以修改的  
	    // const Person * const this;  
	    // 在成员函数后面加const 修饰的是this指针 让指针指向的值也不可以修改  
	    void showPerson() const  
	    {  
	        this->m_B = 100;  
	        // this->m_A = 100; this指针指向的值也不可以被修改 因为修饰了this指针指向的值  
	        // this = NULL; this指针的指向是不允许被修改的  
	    }  
	  
	    // 普通成员函数是可以修改变量的 但是常函数是不能修改的  
	    void func() {  
	        this->m_A = 7;  
	    }  
	  
	    int m_A = 0;  
	    // 特殊变量 即使在常函数中也可以被修改 需要使用关键字mutable  
	    // mutable 可以理解为ROOT 超级用户权限  
	    mutable int m_B = 0;  
	};  
	  
	// 常对象  
	void test() {  
	    // 定义一个常对象  
	    const Person p;  
	    // 定义一个普通对象  
	    Person p1;  
	    // p.m_A = 100; 这样会报错 因为常量无法被修改  
	    // 这样是可以执行的 因为 m_B 使用了mutable关键字  
	    p.m_B = 100;  
	    // 这样也是允许的 因为p1并不是常对象  
	    p1.func();  
	    p1.m_A = 100;  
	}
```