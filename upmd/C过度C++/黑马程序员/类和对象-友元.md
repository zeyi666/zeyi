	生活中你的家有客厅(Public), 有你的卧室(Private)
	客厅所有来的客人都可以进去, 但是你的卧室是私有的, 也就是说只有你能进去
	但是呢, 你也可以允许你的好闺蜜好基友过去
	在程序里, 有些私有属性也想让类外特殊的一些函数或者类进行访问, 就需要用到友元的技术
	友元的目的就是让一个函数或者类 访问另一个类中的私有的对象
	友元的关键字为 > friend <
	友元的三种实现
		- 全局函数做友元
```
		#include <iostream>
		using namespace std;
		
		class Person {
		
		// 告诉编译器 test 函数是 Person类的好朋友 可以访问类中的私有内容 
		friend void test(Person *p);
		
		public:
			Person() { 
				m_a = 17;
				m_b = 20;
			} 
		public:
			int m_a;
		private:
			int m_b; 
		};
		
		void test(Person *p) {
			p->m_a = 27;
			cout << p->m_a << endl;
			cout << p->m_b << endl;
			p->m_b += 10;
			cout << p->m_b << endl;
			return;
		}
		 
		int main() {
			Person p;
			test(&p);
			return 0;
		} 
```
		- 类做友元
```
		class Building;
		class goodGay
		{
			public:
				
				goodGay();
				void visit();
				
			private:
				Building *building;
		};
		
		class Building
		{
			// 告诉编译器 goodGay类是Building类的好朋友, 可以访问到Building类中私有内容
			friend class goodGay;
			
			public:
				Building();
			public:
				string m_sittingRoom; // 客厅
			private:
				string m_BedRoom;
		};
		
		Building::Building()
		{
			this->m_sittingRoom = "客厅";
			this->m_BedRoom = "卧室";
		}
```
		- 成员函数做友元
```
		class Building;
		class goodGay
		{
			public:
				goodGay();
				// 只让visit函数作为Building的好朋友 可以访问Building中的私有内容
				void visit();
			private:
				Building *building;
		};
		
		class Building
		{
			// 告诉编译器goodGay类中的visit函数是Building的好朋友 可以访问私有内容
			friend void goodGay::visit();
			
			public:
				Building();
			
			public:
				string m_SittingRoom; // 客厅
			private:
				string m_BedRoom; // 卧室
		};
		
		Building::Building()
		{
			this->m_SittingRoom = "客厅";
			this->m_BedRoom = "卧室";
		}
		
		goodGay::goodGay()
		{
			building = new Building;
		}
		
		void goodGay::visit()
		{
			cout << "好基友正在访问" << building->m_SittingRoom << endl;
			cout << "好基友正在访问" << building->m_BedRoom << endl;
		}
		
		void goodGay::visit2()
		{
			cout << "好基友正在访问" << building->m_SittingRom << end;
			//cout << "好基友正在访问" << building->BedRom << endl;
		}
		
		void test01()
		{
			goodGay gg;
			gg.visit();
		}
```

---
```
#include <iostream>
using namespace std;

class Person;  // 前向声明Person类，以便在Ppp类中使用
class Ppp {
public:
    void test();  // 声明test函数，用于访问Person类的成员
    void tast();  // 声明tast函数，用于创建Person对象
    ~Ppp();  // 析构函数，没有返回值，不需要参数
    Person *p;    // 声明一个指向Person类的指针

};

class Person {
    friend void Ppp::test();  // 声明Ppp类的test函数为友元函数 可以访问Person类的私有成员
public:
    Person(); // 默认构造函数，用于创建Person类的对象
    int a = 10;  // 公开成员变量a
private:
    int b = 10;  // 私有成员变量b
};

/*
 * Person类的构造函数实现
 * 初始化成员变量a和b
 */
Person::Person() {
    this->a = 7;
    this->b = 17;
}

/*
 * Ppp类的析构函数实现
 * 释放动态分配的Person对象内存
 */

Ppp::~Ppp() {
    delete p;
}

// 实现test函数，通过指针访问Person类的成员
void Ppp::test() {
    cout << p->a << endl;  // 访问Person类的公开成员a
    cout << p->b << endl;  // 访问Person类的私有成员b，因为test是友元函数
}

// 实现tast函数，用于创建Person对象
void Ppp::tast() {
    p = new Person;  // 动态创建Person对象，并将其地址赋值给指针p
}

int main() {
    Ppp a;  // 创建Ppp对象a
    a.tast();  // 调用tast函数，为a.p分配内存
    a.test();  // 调用test函数，输出Person对象的成员值
}
```