	定义函数 fn main() {}
		-没有参数 没有返回
	main函数是Rust可执行程序最先运行的代码
	打印文本
		println!("Hello World!");
		-Rust的缩进是4个空格而不是tab
		-println是一个Rust macro（宏）
			-如果是函数的话就没有！
		-"Hello World!"是字符串 它是println!的参数
		-代码以;结尾
	编译和运行
		运行Rust之前需要先编译
		-rustc hello.rs
		编译成功后会生成一个二进制文件
		-Windows系统上还会生成一个.pdb文件
		Rust是ahead-of-tim编译的语言
		-可以先编译程序 然后把可执行文件发给别人运行（无需Rust）
		rustc只适合简单的Rust程序
	Hello Cargo
		Cargo是Rust的构建系统和包管理工具
		-构建代码、下载依赖的库、构建这些库...
		安装Rust的时候会自动安装Cargo
		-cargo --version
		创建Cargo项目
		-cargo new hello_cargo
		目录
			-Cargo.toml
			-src
				-main.rs
			-初始化了一个新的Git仓库 .gitignore
		Cargo.toml
			toml格式 是Cargo的配置格式
			[pacakge] 是一个区域标题 表示下方内容是用来配置包（package）的
				-name    项目名
				-version 项目版本
				-authors 项目作者
				-edition Rust版本
			[dependencies] 另一个区域的开始
				-会列出项目的依赖项
			在Rust里面 代码的包称作crate
		src/main.rs
			cargo生成的main.rs在src目录下
			而Cargo.toml在项目顶层目录下
			源代码都应该在src目录下
			顶层目录可以放置：README、许可信息、配置文件和其它与程序源码无关的文件
			如果创建项目时没有使用cargo 也可以把项目转换为cargo：
				-把源代码文件移动到src下
				-创建Cargo.toml并填写相应配置
		构建 Cargo 项目
			cargo build
				-创建可执行文件：target/debug/hello_cargo 或 target/debug/hello_cargo.exe（Windows）
				-运行可执行文件：./target/debug/hello_cargo 或 .\target\debug\hello_cargo.exe（Windows）
			第一次运行cargo build会在顶层目录生成cargo.lock文件
				-该文件负责追踪项目依赖的精确版本
				-不需要手动修改该文件
		构建并运行cargo项目
			cargo run
				编译结果+执行结果
				-如果之前编译成功过 并且源码没有改变 那么就会直接运行二进制文件
		检查代码
			cargo check 
				检查代码 确保能通过编译 但是不会产生任何可执行文件
				cargo check 要比 cargo build 快得多
					-编写代码的时候可以连续反复使用cargo check检查代码 提高效率
		为发布构建
			cargo build --release
				-编译时会进行优化
					-代码会运行的更快 但是编译时间更长
				-会在 target/release 而不是 target/debug生成可执行文件