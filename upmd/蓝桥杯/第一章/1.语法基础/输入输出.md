输入输出函数

	scanf() && printf()
	这是C语言原生输入输出函数
```
		#include <bits/stdc++.h>
		using namespace std;
		
		int main() {
			int a,b;
			scanf("%d %d",&a,&b);
			printf("%d,%d\n",a,b);
		}
		

---
输入: 2 4
---
输出: 2,4
---
%d : 标识符 在这里表示整数
"%d %d" : 字符串 在这里表示" 整数 空格 整数 "
& : 取址符
scanf("%d %d",&a,&b);
将读取到的数据 以指针的方式传入变量a b的地址
```

```
		#include <bits/stdc++.h>
		using namespace std;
		
		int main() {
			int a[10];
			scanf("%s",a);
			printf("%s\n",a);
		}
		
---
输入: Hello World
---
输出: Hello
---
%s输入遇到空格或回车就会停下
没有取址符&是因为字符串本身就是一个指针(地址)了
a是字符串的首地址 所以不需要使用取址符
\0 : 在字符串中表示结束符
```

```
		#include <bits/stdc++.h>
		using namespace std;
		
		int main() {
			int a[10];
			scanf("%[^\n]",a);
			printf("%s\n",a);
		}
		
---
输入: Hello World
---
输出: Hello World
---
^ : 表示排除
\n : 表示换行符 （转义字符）
scanf("%[^\n]",a); : 表示读取的输入只要不是换行符就会一直读
```

```
	类型        对应标识符
	int         %d
	double      %lf
	char        %c
	char[]      %s
	long long   %lld
```

	scanf() printf() 优势
		1.效率高
		2.格式化输入输出

	cin && cout
```
	#include <bits/stdc++.h>
	using namespace std;
	
	int main()
	{
		int a,b;
		cin >> a >> b;
		cout << a << ' ' << b << '\n';
		return 0;
	}	
	
---
输入: 2 3
---
输出: 2 3
---
\n 速度比 endl 更快 因为endl是关键字
```

```
	#include <bits/stdc++.h>
	using namespace std;
		
	int main()
	{
		double a,b;
		cin >> a >> b;
		cout << fixed << setprecision(3) << a << ' ' << b << '\n';
		return 0;
	}	
	
---
输入: 2 3
---
输出: 2 3
---
\n 速度比 endl 更快 因为endl是关键字
输入小数想保留小数点后第几位需要使用关键字
	fixed 然后接着 setprecision(3)
	() 里是保留小数点后第几位
```

```
	#include <bits/stdc++.h>
	using namespace std;
	
	int main()
	{
		string s;
		getline(cin, s);
		cout << s;
		return 0;
	}	
	
---
输入: Hello World
---
输出: Hello World
---
因为像这样
	char s[10];
	cin >> s;
cin输入字符串读到空格和换行符也会停止
所以要使用getline来直接读取一行输入
```

取消同步流

	由于cin和cout需要自动判断变量类型等内部原因, 读写效率比scanf和peintf更低
	当数据量较大时, 可能导致程序运行超时
	我们可以通过取消同步流来加速cin和cout, 加速后效率相差无几
```
	#include <bits/stdc++.h>
	using namespace std;
	
	int main()
	{
		// 取消同步流
		ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
		
		// 其他操作不变
		int x;
		cin >> x;
		cout << x << '\n'
		
		return 0;
	}
```