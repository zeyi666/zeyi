# 【总结文档】时空复杂度详解

## 前言：竞赛中的时间与空间限制

### 时间限制到底是什么意思？

比赛中，每道题都有时间限制：

- 简单题：1秒内完成
- 中等题：2秒内完成
- 困难题：可能给你5秒

**关键问题**：1秒能做多少事情？

- 现代计算机1秒大约能执行 10^8 次简单操作（加减乘除、比较等）
- 如果你的算法需要 10^9 次操作，就会超过1秒的限制 → TLE ❌
- 如果只需要 10^7 次操作，就能轻松通过 → AC ✅

### 空间限制是什么？

每道题还会限制你能用多少内存，比如：

- 64MB、128MB、256MB、512MB等

**快速换算**：

- 1个 `int` = 4字节
- 100万个 `int` = 4MB
- 如果你开了一个 `int a[100000000]` (1亿个int)，就需要400MB
- 如果题目只给256MB，你就会得到"Memory Limit Exceeded (MLE)" ❌

## 1. 复杂度表示方法

### 大O记号 - 你只需要懂这一个！

在竞赛中，几乎只用大O记号，写作 O(f(n))。

**通俗理解**：

- n 是数据规模（比如数组长度、循环次数等）
- O(f(n)) 表示当 n 很大时，算法大概需要执行 f(n) 次操作

**举个例子**：

- 如果算法是 O(n^2)，数据规模 n=1000
- 那么大概需要 1000^2 = 10^6 次操作
- 10^6 < 10^8，所以1秒内能完成 ✅

## 2. 时间复杂度详解

### 常见复杂度排行榜（从快到慢）

| 复杂度        | 名称   | n=10^3n=103时的操作次数 | n=10^6n=106时的操作次数 | 评价   |
| ---------- | ---- | ----------------- | ----------------- | ---- |
| O(1)       | 常数   | 1                 | 1                 | 超快⚡  |
| O(log n)   | 对数   | ~10               | ~20               | 很快🚀 |
| O(n)       | 线性   | 10^3              | 10^6              | 快👍  |
| O(n log n) | 线性对数 | ~10^4             | ~2×10^7           | 还行😐 |
| O(n^2)     | 平方   | 10^6              | 10^12             | 慢😞  |
| O(n^3)     | 立方   | 10^9              | 10^18             | 很慢💀 |
| O(2^n)     | 指数   | 2^1000            | 天文数字              | 超慢☠️ |

### 2.1 常数复杂度 O(1)

不管数据多大，都是固定时间完成。

```cpp
// 获取数组第一个元素
int getFirst(int a[], int n) {
    return a[0];  // 只要1步，跟n没关系
}

// 判断一个数是否为偶数
bool isEven(int x) {
    return x % 2 == 0;  // 1步搞定
}
```

**竞赛中的例子**：查表、数组下标访问、四则运算等。

### 2.2 对数复杂度 O(log n)

每一步都把问题规模砍掉一半！

```cpp
// 二分查找：在有序数组中找目标值
int binarySearch(int a[], int n, int target) {
    int l = 0, r = n - 1;
    
    while (l <= r) {
        int mid = (l + r) / 2;
        
        if (a[mid] == target) 
            return mid;         // 找到了
        else if (a[mid] < target) 
            l = mid + 1;        // 去右半边找
        else 
            r = mid - 1;        // 去左半边找
    }
    
    return -1;  // 没找到
}
```

**为什么是 O(log n)**：

- 第1步：搜索范围 n
- 第2步：搜索范围 n/2
- 第3步：搜索范围 n/4
- ...
- 第k步：搜索范围 n/2^k = 1

所以 k = log_2 n，复杂度就是 O(log n。

**竞赛技巧**：看到"有序"、"查找"就想到二分！

### 2.3 线性复杂度 O(n) - 一遍扫描

需要把每个数据看一遍。

```cpp
// 找数组中的最大值
int findMax(int a[], int n) {
    int maxVal = a[0];
    
    for (int i = 1; i < n; i++) {      // 循环n-1次
        if (a[i] > maxVal) {
            maxVal = a[i];
        }
    }
    
    return maxVal;
}

// 计算数组元素之和
int sum(int a[], int n) {
    int s = 0;
    for (int i = 0; i < n; i++) {      // 循环n次
        s += a[i];
    }
    return s;
}
```

**识别技巧**：一层循环，循环 n 次 → O(n)

### 2.4 线性对数复杂度 O(n log n) -

经典代表：归并排序、快速排序、堆排序

```cpp
// 归并排序的合并函数
void merge(int a[], int l, int mid, int r) {
    int temp[r - l + 1];  // 临时数组
    int i = l, j = mid + 1, k = 0;
    
    // 合并两个有序部分
    while (i <= mid && j <= r) {
        if (a[i] <= a[j]) 
            temp[k++] = a[i++];
        else 
            temp[k++] = a[j++];
    }
    
    // 处理剩余元素
    while (i <= mid) temp[k++] = a[i++];
    while (j <= r) temp[k++] = a[j++];
    
    // 复制回原数组
    for (i = l; i <= r; i++) {
        a[i] = temp[i - l];
    }
}

// 归并排序主函数
void mergeSort(int a[], int l, int r) {
    if (l < r) {
        int mid = (l + r) / 2;
        mergeSort(a, l, mid);        // 排序左半部分
        mergeSort(a, mid + 1, r);    // 排序右半部分
        merge(a, l, mid, r);         // 合并结果
    }
}
```

**为什么是 O(n log n)**：

- 分治思想：把数组分成两半，递归排序，然后合并
- 分治深度：log n 层
- 每层合并：需要 O(n) 时间
- 总时间：O(n) × log n = O(n log n)

**竞赛经验**：10^5 以内的数据，O(n log n) 算法完全没问题！

### 2.5 平方复杂度 O(n^2)O(n2) - 双重循环

最容易写出的复杂度。

```cpp
// 冒泡排序：相邻元素两两比较
void bubbleSort(int a[], int n) {
    for (int i = 0; i < n; i++) {          // 外层循环n次
        for (int j = 0; j < n - i - 1; j++) {   // 内层循环n-i-1次
            if (a[j] > a[j + 1]) {
                // 交换a[j]和a[j+1]
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
}

// 找出数组中所有的数对
void findAllPairs(int a[], int n) {
    for (int i = 0; i < n; i++) {          // 外层循环
        for (int j = i + 1; j < n; j++) {   // 内层循环
            printf("(%d, %d)\n", a[i], a[j]);
        }
    }
}
```

**操作次数计算**：

- 第一个例子：n + (n-1) + (n-2) + ... + 1 = frac{n(n+1)}{2} ≈ frac{n^2}{2}
- 第二个例子：(n-1) + (n-2) + ... + 1 = frac{n(n-1)}{2} ≈ frac{n^2}{2}

**竞赛建议**：

- n ≤ 10^3：O(n^2) 算法OK
- n ≤ 10^4：O(n^2) 勉强能过
- n ≥ 10^5：O(n^2) 基本超时

### 2.6 立方复杂度 O(n^3) - 三重循环

```cpp
// Floyd-Warshall算法：求任意两点间最短路径
void floyd(int dist[][MAXN], int n) {
    for (int k = 0; k < n; k++) {          // 中转点
        for (int i = 0; i < n; i++) {       // 起点
            for (int j = 0; j < n; j++) {   // 终点
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
}
```

**竞赛使用范围**：

- n ≤ 200 ：还行
- n ≤ 500 ：勉强
- n ≥ 1000 ：基本无望

### 2.7 指数复杂度 O(2^n) - 暴搜噩梦

```cpp
// 递归求斐波那契数列（低效版本）
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);  // 每次分成两个子问题
}
```

**为什么这么慢**：

- fib(n) = fib(n-1) + fib(n-2)fib(n)=fib(n−1)+fib(n−2)
- fib(n-1) = fib(n-2) + fib(n-3)fib(n−1)=fib(n−2)+fib(n−3)
- fib(n-2) = fib(n-3) + fib(n-4)fib(n−2)=fib(n−3)+fib(n−4)
- ...

你会发现很多重复计算！比如 fib(n-2)fib(n−2) 被算了很多遍。

**竞赛警告**：O(2^n) 算法通常只能处理 n ≤ 20 的数据！

### 2.8 特殊：调和级数复杂度 O(n log n)

这是一个容易被忽略但很重要的复杂度：

```cpp
// 统计所有因数对的数量
int countDivisors(int n) {
    int cnt = 0;
    for (int i = 1; i <= n; i++) {           // 外层循环n次
        for (int j = i; j <= n; j += i) {     // 内层：i的倍数
            cnt++;
        }
    }
    return cnt;
}
```

**复杂度分析**：

- 当 i=1 ：内层循环 frac{n}{1} 次
- 当 i=2 ：内层循环 frac{n}{2} 次
- 当 i=3 ：内层循环 frac{n}{3}​ 次
- ...
- 当 i=n：内层循环 frac{n}{n} = 1次

总次数：frac{n}{1} + frac{n}{2} + frac{n}{3} + ... + frac{n}{n} = n(frac{1}{1} + frac{1}{2} + frac{1}{3} + ... + frac{1}{n})

后面的括号部分是调和级数，约等于 ln n，所以总复杂度是 O(n log n)。

## 3. 空间复杂度详解

### 基本数据类型的内存占用

| 类型          | C++占用字节 | 能存储的范围         |
| ----------- | ------- | -------------- |
| `bool`      | 1       | true/false     |
| `char`      | 1       | -128~127       |
| `int`       | 4       | -2^31 ~ 2^31−1 |
| `long long` | 8       | -2^63 ~ 2^63−1 |
| `float`     | 4       | 单精度浮点          |
| `double`    | 8       | 双精度浮点          |

### 数组占用内存计算

```cpp
int a[1000];           // 4 * 1000 = 4KB
int b[1000000];        // 4 * 10^6 = 4MB  
int c[100000000];      // 4 * 10^8 = 400MB (可能MLE!)

bool visited[1000000]; // 1 * 10^6 = 1MB
char s[1000000];       // 1 * 10^6 = 1MB

// 二维数组
int dp[1000][1000];    // 4 * 10^6 = 4MB
int matrix[5000][5000]; // 4 * 25 * 10^6 = 100MB
```

### 3.1 常数空间复杂度 O(1)

只用固定的几个变量，不管数据多大。

```cpp
// 找最大值：只用一个变量存结果
int findMax(int a[], int n) {
    int maxVal = a[0];           // 4字节
    
    for (int i = 1; i < n; i++) { // 4字节
        if (a[i] > maxVal) {
            maxVal = a[i];
        }
    }
    
    return maxVal;
}
// 总共只用了8字节，空间复杂度O(1)
```

### 3.2 线性空间复杂度 O(n)

需要额外申请与输入规模成正比的空间。

```cpp
// 复制数组：需要开辟新的数组
int* copyArray(int a[], int n) {
    int* b = new int[n];    // 需要4n字节的新空间
    
    for (int i = 0; i < n; i++) {
        b[i] = a[i];
    }
    
    return b;
}

// 计数排序：需要额外的计数数组
void countSort(int a[], int n, int maxVal) {
    int count[maxVal + 1];   // 需要4*(maxVal+1)字节
    
    // 初始化计数数组
    for (int i = 0; i <= maxVal; i++) {
        count[i] = 0;
    }
    
    // 统计每个数字的出现次数
    for (int i = 0; i < n; i++) {
        count[a[i]]++;
    }
    
    // ... 后续处理
}
```

### 3.3 平方空间复杂度 O(n^2)

通常是二维数组。

```cpp
// 动态规划：最长公共子序列
int longestCommonSubsequence(string s1, string s2) {
    int m = s1.length(), n = s2.length();
    int dp[m+1][n+1];  // 需要4*(m+1)*(n+1)字节
    
    // 初始化边界条件
    for (int i = 0; i <= m; i++) dp[i][0] = 0;
    for (int j = 0; j <= n; j++) dp[0][j] = 0;
    
    // 填表
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i-1] == s2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    
    return dp[m][n];
}
```

### 3.4 递归调用栈的空间复杂度

递归会占用调用栈空间，深度就是空间复杂度！

```cpp
// 递归计算阶乘
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n-1);  // 递归深度为n
}
// 空间复杂度：O(n) - 因为递归深度为n

// 二分递归查找
int binarySearchRecursive(int a[], int l, int r, int target) {
    if (l > r) return -1;
    
    int mid = (l + r) / 2;
    if (a[mid] == target) return mid;
    
    if (a[mid] > target) 
        return binarySearchRecursive(a, l, mid-1, target);
    else 
        return binarySearchRecursive(a, mid+1, r, target);
}
// 空间复杂度：O(log n) - 因为递归深度为log n
```

## 4. 竞赛中的复杂度估算技巧

### 4.1 快速判断算法能否通过

**经验公式**：

- 1秒内能执行 10^8 次基本操作
- 根据时间限制T秒，你的算法操作次数应该 ≤ T × 10^8

**数据规模与算法选择**：

- n ≤ 10 ：任何算法，包括 O(n!)O(n!)
- n ≤ 20 ：O(2^n) 的指数算法
- n ≤ 100 ：O(n^3) 的算法
- n ≤ 1000 ：O(n^2) 的算法
- n ≤ 10^5 ：O(n log n) 的算法
- n ≤ 10^6 ：O(n)) 的算法
- n > 10^6 ：只能用 O(log n) 或 O(1) 的算法

### 4.2 循环嵌套层数判断法

**一层循环**：

```cpp
for (int i = 0; i < n; i++) {
    // 基本操作
}
// 时间复杂度：O(n)
```

**二层循环**：

```cpp
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // 基本操作  
    }
}
// 时间复杂度：O(n²)
```

**三层循环**：

```cpp
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        for (int k = 0; k < n; k++) {
            // 基本操作
        }
    }
}
// 时间复杂度：O(n³)
```

**特殊情况**：内层循环范围会变化

```cpp
for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {  // 注意：j从i开始
        // 基本操作
    }
}
// 内层循环次数：n + (n-1) + (n-2) + ... + 1 = n(n+1)/2
// 时间复杂度：仍然是O(n²)
```

### 4.3 递归算法的复杂度分析(选学)

**主定理（简化版）**： 

	对于递归式 T(n) = aT(frac{n}{b}) + O(n^c):
		- 如果 c < log_b a，则 T(n) = O(n^{log_b a})
		- 如果 c = log_b a，则 T(n) = O(n^c log n)
		- 如果 c > log_b a，则 T(n) = O(n^c)

**常见例子**：

```cpp
// 归并排序：T(n) = 2T(n/2) + O(n)
// a=2, b=2, c=1, log₂2=1，所以c=log_b a
// 复杂度：O(n log n)

// 二分查找：T(n) = T(n/2) + O(1)  
// a=1, b=2, c=0, log₂1=0，所以c=log_b a
// 复杂度：O(log n)
```

## 5. 竞赛心得与建议

### 5.1 见到题目如何快速估算复杂度

**Step 1**：看数据范围

- n ≤ 10 → 什么算法都行，甚至暴搜
- n ≤ 100 → O(n^3)算法OK
- n ≤ 1000 → O(n^2)算法OK
- n ≤ 10^5 → 需要O(n log n)或更优算法
- n ≤ 10^6 → 需要O(n)或更优算法

**Step 2**：看时间限制

- 1秒 → 算法操作次数应该 ≤ 10^8
- 2秒 → 算法操作次数应该 ≤ 2×10^8

**Step 3**：结合起来判断 例如：n=10^5，时间限制1秒

- O(n^2) = 10^10 → 超时❌
- O(n log n) = 10^5 × 17 ≈ 1.7×10^6 → 通过✅

### 5.2 常见算法的复杂度速查表

| 算法类型     | 时间复杂度       | 空间复杂度    | 适用数据规模   |
| -------- | ----------- | -------- | -------- |
| 线性搜索     | O(n)        | O(1)     | n ≤ 10^6 |
| 二分搜索     | O(log n)    | O(1)     | 任意       |
| 冒泡排序     | O(n^2)      | O(1)     | n ≤ 10^3 |
| 快速排序     | O(n log n)  | O(log n) | n ≤ 10^5 |
| 归并排序     | O(n log n)) | O(n)     | n ≤ 10^5 |
| 堆排序      | O(n log n)  | O(1)     | n ≤ 10^5 |
| 计数排序     | O(n+k)      | O(k)     | 当k不太大时   |
| DFS/BFS  | O(V+E)      | O(V)     | 图论问题     |
| Floyd算法  | O(n^3)      | O(n^2)   | n ≤ 500  |
| Dijkstra | O(E log V)O | O(V)     | 单源最短路    |

### 5.3 经典错误与避坑指南

**错误1**：循环边界写错导致复杂度变化

```cpp
// 错误：这样写是O(n²)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {  // 应该是j < i
        // ...
    }
}
```

**错误2**：递归没有记忆化

```cpp
// 错误：每次都重新计算，指数复杂度
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);
}

// 正确：加上记忆化，线性复杂度
int memo[100005];
int fib(int n) {
    if (n <= 1) return n;
    if (memo[n] != -1) return memo[n];
    return memo[n] = fib(n-1) + fib(n-2);
}
```

**错误3**：不必要的重复计算

```cpp
// 错误：每次都重新计算size()
for (int i = 0; i < vec.size(); i++) {
    // vec.size()在循环中被调用n次
}

// 正确：提前计算一次
int n = vec.size();
for (int i = 0; i < n; i++) {
    // 只计算一次size()
}
```

## 总结

### 核心要点回顾

1. **时间复杂度**：衡量算法速度，关键是看循环嵌套层数
2. **空间复杂度**：衡量内存使用，主要看数组和递归深度
3. **大O记号**：关注增长趋势，忽略常数项
4. **估算公式**：1秒≈10^8次基本操作
5. **数据规模**：根据n的大小选择合适的算法

### 学习建议

1. **多做题**：通过大量练习培养复杂度直觉
2. **先分析再编码**：养成先分析复杂度的习惯
3. **从暴力开始**：先想暴力解法，再考虑优化
4. **关注数据范围**：这是选择算法的关键线索
5. **时常总结**：记录常见算法的复杂度