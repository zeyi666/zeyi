	bool类型
		C标准库没有bool类型 只有_Bool用来代替int判断1 or 0
		但是C99提供了 stdbool.h 头文件
			stdbool.h头文件里面将bool定义为_Bool的别名 
			并使用 true or false 来代替1 or 0
			包含该文件后可与C++兼容 C++里bool,true ,false为关键字
	getchar()
		getchar()不局限于键盘的输入 而是输入一个字符 包括文件的...
		putchar()也是输出一个字符 包括文件的...
		getchar() 会读所有字符（包括空格、换行 \n 、制表符 \t ）
		scanf 和 getchar 混用的冲突
			 scanf("%d", &num) 读数字时 会跳过空格/换行 
			 但不会吃掉最后的换行符 
				 比如输入 123\n scanf 读走 123 但 \n 留在缓冲区
				 下一个 getchar() 会直接读到 \n 导致逻辑乱跳
				解决：
					scanf 后加 while (getchar() != '\n') 
					清理残留换行符
	const
		将定义设置为只读 这样就无法被修改数据
	字符串
		字符串是以空字符（\0）结尾的char类型数组
		用""括起来的内容是字符串常量且被视为该字符串的地址
		存储字符串的数组名也被看作是地址
	puts()函数和printf()函数
		两个函数同属于stdio.h的输入/输出函数
		不同点是 pust() 只显示字符串并且自动在末尾加上换行符
	分段错误 （Segmentation fault）
		该错误表示程序试图访问未分配的内存
	空字符和空指针
		空字符用于标记字符串末尾（'\0'）
		空指针有一个值  该值不会与任何数据的有效地址对应
		空字符是整数类型 空指针是指针类型 它们都可以用数值0表示
		但是 两者是不同类型的0
		空字符是一个字符 占1字节
		空指针是一个地址 占4字节
	scanf()
		scanf()会返回一个整数值 该值等于scanf()的项数或EOF（读到文件结尾返回）
	寄存器变量
		寄存器变量存储在最快的可用内存当中（足够幸运可以存储在CPU的寄存器）
		因为寄存器变量存储在寄存器而不是内存 所以无法直接获取地址
		声明变量为 register 即可请求生成寄存器变量
		编译器会根据寄存器或最快可用内存的数量来衡量你的请求  或者 直接忽略请求
		并且可申明的数据类型有限 处理器中的寄存器可能没有足够大的空间存储double
	extern()
		int tern =1; // 外部变量
		extern int tern; // 内部
		第一次声明为变量预留了存储空间 该声明构成了变量的定义
		第2次声明是告诉编译器使用之前已经创建好的tern
		extern表示该声明不是定义 指示编译器去别处查找其定义
	内存泄漏
		内存被耗尽
		例如无限循环使用malloc()创建内存块 最后内存被耗尽
	指向标准文件的指针
		stdio.h头文件把3个文件指针与3个标准文件相关联 
		C程序会自动打开这3个标准文件
		   标准文件    文件指针   通常使用的设备
		   标准输入    stdin     键盘
		   标准输出    stdout    显示器
		   标准错误    stderr    显示器
		这些文件指针都是指向FILE的指针  所以它们可用作标准I/O函数的参数
		如fclose(fp)中的fp
	fopen()
		C语言标准I/O通过 fopen 打开文件并创建缓冲区（读写模式会创建两个）和包含文件及缓冲区数据的结构
		后续输入函数从缓冲区读取数据（读完则从文件再拷贝数据到缓冲区）
		输出函数将数据写入缓冲区（满则拷贝至文件）所有操作依赖该结构实现
	有符号类型和无符号类型
		signed -> 有符号类型
		unsigned -> 无符号类型
	数组声明
		int data[max];
		max必须是整数常量的组合 枚举常量和sizeof表达式 不包括const声明的值
		C++可以把const作为常量表达式的一部分 C语言不行
	通用工具库
		stdlib.h
	