	fopen();
		第一个参数是待打开文件的名称
			包含该文件名的字符串地址
		第二个参数是一个字符串 指定待打开文件的模式
			普通
				"r" -> 以读的方式打开文件
				"w" -> 以写模式打开文件 把现有文件长度截为0 如果文件不存在 则创建一个文件
				"a" -> 以写模式打开文件 在现有文件末尾添加内容 如果文件不存在 则创建一个文件
				"r+" -> 以更新模式打开文件（即可以读写文件）
				"w+" -> 以更新模式打开文件（即 读和写）把现有文件长度截为0 如果文件不存在 则创建一个文件
				"a+" -> 以更新模式打开文件（即 读和写）在现有文件末尾添加内容 如果文件不存在 则创建一个文件 可以读整个文件 但是只能在末尾添加内容
			二进制 与上一个模式类似 但是以二进制模式而不是文本模式打开文件
				"rb"
				"wb"
				"ab"
				"rb+"
				"r+b"
				"wb+"
				"w+b"
				"ab+"
				"a+b"
			独占模式 如果文件已存在或以独占模式打开文件 则打开文件失败
				"wx"
				"wbx"
				"w+x"
				"wb+x" or "w+bx"
	FILE
			FILE *fp;
			该例子中fp是指向FILE的指针 FILE是一个定义在stdio.h中的派生类型
			文件指针fp并不指向实际的文件 它指向一个包含文件信息的数据对象
			其中包含操作系统的I/O函数所用的缓冲区信息
			因为标准库中的I/O函数使用缓冲区
			所以它们不仅要知道缓冲区的我位置
			还要知道缓冲区被填充的程度 以及操作哪一个文件
			标准I/O函数根据这些信息在必要时决定再次填充或清空缓冲区
			fp指向的数据对象包含了这些信息（数据对象是一个C结构）
	getc() and putc()
		与getchar() putchar() 类似
		不同的是 要告诉getc()和putc()函数使用哪一个文件
		ch = getc(fp) -> 从fp指定的文件中获取一个字符
		putc(ch,fpout) -> 把字符ch放入FILE指针fpout指定的文件中
			第一个参数是待写入的字符 第二个参数是文件指针
	fclose()
		fclose(fp)函数关闭fp指定的的文件  必要时刷新缓冲区
		如果成功关闭文件返回0 否则 返回EOF
		如果磁盘已满 移动硬盘被移除或出现I/O错误 都会导致调用fclose()函数失败
	文件I/O
		文件I/O函数和前面I/O函数的区别
			文件I/O函数都要用FILE指针指定待处理的文件 与getc() putc()类似
			这些函数都要求用指向FILE的指针指向一个文件 或者使用fopen()的返回值
			fprintf() 和 fscanf()
				文件I/O函数 fprintf()和fscanf()函数的工作方式与printf()和scanf()类似
				区别在于前者需要使用一个参数指定一个文件
			rewind()
				回到文件开始处 接收一个文件指针作为参数
			fseek()
				第一个参数是FILE指针 指向待查找的文件 fopen()应该已打开文件
				第二个参数是偏移量 该参数表示从初始点开始要移动的距离 该参数必须是一个long类型的值 可以为正（前移）负（后移）或 0（保持不动）
				第三个参数是模式 该参数确定起始点
				根据ANSI标准 在stdio.h头文件中规定了几个表示模式的明示常量
					SEEK_SET -> 文件开始处
					SEEK_CUR -> 当前位置
					SEEK_END -> 文件末尾
					旧的实现可能缺少这些定义 可以使用0L 1L 2L 表示这三种模式
					如果正常返回0 错误返回-1
			ftell()
				该函数返回类型是long 他返回的是参数指向文件的当前位置距文件开始处的字节数
			fgetpos() 和 fsetpos
				功能和fseek() ftell()一样 但是可以处理较大文件
				这两个函数不使用long类型的值表示位置 它们使用新类型
					fpos_t
					fpot_t类型不是基本类型  它根据其他类型来定义
					fpos_t类型的变量或数据对象可以在文件中指定一个位置 它不能是数组类型 除此之外没有其他限制
	int ungetc(int c,FILE *fp)
		把C指定的字符放回输入流中
	int fflush(FILE *fp)
		手动提前清理缓冲区
	int setvbuf(FILE *  restrict fp,char * restrict buf,int mode,size_t size);
		手动制定缓冲区规矩
		int  *fp = (char *)malloc(30 * sizeof(char))
		setvbuf(fp,buf,_IOFBF,30 * sizeof(char));
		参数1 -> 要配置的文件指针
	    参数2 -> 自定义缓冲区（暂存点）
	    参数3 -> 规矩（模式）
		    _IOFBF 满缓冲
		    _IOLBF 行缓冲
		    _IONBF 无缓冲
	    参数4 -> 大小
	size_t fread() and size_t fwrite() 用于以二进制形式处理数据
		都接收4个参数
		参数1 -> 数据对象
		参数2 -> 字节大小
		参数3 -> 数量
		参数4 -> 文件指针
	int feof(FILE *fp) 和 int ferror(FILE *fp) 函数
	如果标准输入函数返回EOF 则通常表明函数已经到达文件结尾 或者 读写错误
	feof() 和 ferror() 函数通常用于区分这两种情况
	当上一次输入调用检测到文件结尾时 feof()函数返回一个非0值 否则返回 0
	当读或写出现错误时 ferror() 函数返回一个非0值 否则返回0