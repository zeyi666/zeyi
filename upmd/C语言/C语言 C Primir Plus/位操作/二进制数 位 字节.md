	按位运算符
		一元运算符 ~ 把1变为0 把0变为1
			~ (10011010) // 表达式
			(01100101) // 结果值
			假设val类型是unsigned char 已被赋值2 在二进制中00000010表示2
			那么 ~val的值为 11111101 即253
		二元运算符 & 通过逐位比较两个运算对象 生成一个新值
			只有两个运算对象中相应的位值为1时 结果才为1
			(10010011) & (00111101) // 表达式
			(00010001) // 结果值
			val &= 0377 == val = val & 0377;
		二元运算符 | 通过逐位比较两个运算对象 生成一个新值
			只要两个运算对象中相应的一个位是1 那么结果为1
			(10010011) & (00111101) // 表达式
			(10111111) // 结果值
			val |= 0377 == val = val | 0377;
		二元运算符 ^ 通过逐位比较两个运算对象 生成一个新值
			只有两个运算对象中相应的一个位是1 另一个不为1 那么结果为1
			(10010011) ^ (00111101) // 表达式
			(10101110) // 结果值
			val ^= 0377 == val = val ^ 0377;
		掩码
			相当于过滤器 掩码中的每一位都是0和1相当于关和开
		关闭位(清空位)
			00001111（原灯板）
			00000010（掩码）
			使用二元运算符 & 进行对比 -> 00001101
			成功关闭2号位
			flags &= ~MASK;
		切换位
			00001111（原灯板）
			00000010 掩码进行取反 -> 11111101
			使用二元运算符 ^ 进行对比 -> 00001101
			成功切换2号位 开关状态
			flags ^= MASK;
		检查位
			00001111（原灯板）
			00000100（掩码）
			使用二元运算符 & 进行对比 -> 00000100
			if (结果 == 掩码) 说明灯亮
			if ((flags & MASK) == MASK);
			由于按位运算符优先级低于==所以必须加上()
	移位运算符
		左移 << 将其左侧运算对象每一位的值向左移动指定的位数 如果超出会用0填充
			(10001010) << 2; // 表达式
			(00101000) // 结果值
			该操作会产生新的位值 但是不改变其运算对象 假设stonk为1 
			stonk<<2为4 但是stonk本身是不变的 除非赋值 <<=（自动赋值）
		右移 << 将其左侧运算对象每一位的值向右移动指定的位数 
			对于有符号类型 如果超出 可用0填充或者用符号的副本填充
			对于无符号类型 如果超出 用0填充
			(10001010) >> 2; // 表达式
			(00100010) // 无符号结果值 有符号结果值
			(11100010) // 有符号结果值
			赋值 >>=（自动赋值）
	位字段
		通过一个结构声明来建立
		struct {
		    unsigned int autfd : 1;
		    unsigned int bldfc : 4;
		    unsigned int undln : 8;
		    unsigned int itals : 1;
		} prnt;
		: 后面是字段范围
		要确保所赋的值不超过字段范围