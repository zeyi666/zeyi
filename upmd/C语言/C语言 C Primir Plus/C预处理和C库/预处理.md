	预处理器查找一行中以#号开始的预处理器指令
	明示常量 #define
		#define PX printf("%d",x);
		#define -> 预处理器指令
		PX -> 宏
		printf("%d",x); -> 替换体
		记号
			#define FOUR 2*2
			该宏定义有一个记号2*2序列
			#define FOUR 2*  3
			该宏定义有三个记号2、*、3序列
	在#define中使用参数
		#define SQUARE(X) X*X
		z = SQUARE(5);
		用宏参数创建字符串
			#define PSQR(X) printf("The square X is %d.\n",((X)*(X)));
		预处理器粘合剂
			#define XNAME(n) x ## n
			XNAME(3); -> x3
		变参宏
			#define PR(...) printf(__VA_ARGS__)
			调用时会将...的内容移动到__VA_ARGS__
			PR("Hello"); -> printf("Hello");
	文件包含 #include
		#include <stdio.h> -> 查找系统文件
		#include "stdio.h" -> 查找当前文件目录
		#include "/usr/biff/stdio.h" -> 查找指定文件目录
	取消#define指令 #undef
		#define LIMIT 400
		undef LIMIT -> 这样就可以再重定义LIMIT
	条件编译
		#ifdef 
			用于判断指定标识符是否已定义
			若定义则编译其后到 #else 或 #endif 间的代码
		#else 搭配 #ifdef 
			当标识符未定义时编译其到 #endif 间的代码 是条件分支的“另一种情况”
		#endif 
			标记条件编译指令的结束 界定 #ifdef 和 #else 所控制代码块的范围 
			让编译器明确条件判断的边界
		应用示例
			#ifdef 宏名
			// 已定义时执行
			#else
			// 未定义时执行
			#endif
		#ifndef
			与ifdef相反 用来判断宏是否未定义
		应用示例
			头文件保护
			#ifndef XXX_H_ // 检查 XXX_H_ 是否未定义
			#define XXX_H_  // 第一次包含时 定义 XXX_H_
			void MyFunc(); // 头文件内容
			#endif // 结束保护
		#if #else #elif
			跟代码里的if、else、else if 一样
		应用示例
			假设你有不同硬件平台（ PLATFORM_A  /  PLATFORM_B  ）
			想编译对应代码：
			#define PLATFORM_A 1  // 假设当前是平台 A
			#if PLATFORM_A == 1
			    void InitForA() { ... }  // 编译平台 A 的初始化代码
			#elif PLATFORM_B == 1
			    void InitForB() { ... }  // 编译平台 B 的初始化代码
			#else
			    #error "未知平台！"  // 都不匹配，直接报错
			#endif
			还能结合 defined 关键字 判断宏 是否定义 而非宏的值：
			#if defined(DEBUG) && DEBUG >= 2  // DEBUG 已定义 且值 >=2
			    printf("详细调试信息：%d\n", var);  // 编译详细调试代码
			#elif defined(DEBUG)
			    printf("简略调试：%d\n", var);  // 只定义了 DEBUG
			#else
			    // 啥都不做
			#endif
		预定义宏
			宏名
			 __DATE__  
				 含义
					 编译日期 格式  "MMM dd yyyy"（比如"Aug 20 2025"） 
				示例
					 printf("编译日期：%s\n", __DATE__);  
			 __FILE__  
				 含义
					 当前源文件名（字符串）调试时定位文件超好用 
				 示例
					 printf("出错文件：%s\n", __FILE__);  
			 __LINE__  
				 含义
					 当前代码的行号（整数）结合  __FILE__  能定位错误位置 
				 printf("出错行：%d\n", __LINE__);  
			 __STDC__  
				 含义
					 标识是否遵循 C 标准 值为 1 表示遵循（一般编译器都支持） 
				 示例
					 #if __STDC__ != 1  
					 #error "需符合 C 标准！"   
					 #endif  
			 __STDC_VERSION__  
				 含义
					 C 标准版本，比如 C11 是 201112L C17 是 201710L 
				示例
					 #if __STDC_VERSION__ < 201112L 
					 #error "需 C11 及以上！"   
					 #endif  
			 __TIME__  
				 含义
					 编译时间 格式  "hh:mm:ss"（比如  "14:28:30" ）  
				 示例
					 printf("编译时间：%s\n", __TIME__);
		#line and #error
			#line 手动修改 __LINE__ 和 __FILE__ 
				作用
					调试时 把编译器的行号 文件名 “骗” 成你想要的 方便定位问题
				示例：
					#line 100 "original.proto"
					void SomeGeneratedFunc() {
					    // 如果这里出错 original.proto:105: 错误...
					}
			#error 让编译器直接报错 终止编译
				作用
					条件不满足时 强制让编译失败 给出自定义错误信息
				​示例
					你要求代码必须用 C11 标准编译
					#if __STDC_VERSION__ != 201112L
				    #error "必须用 C11 标准编译！"  // 不满足就报错
					#endif
		#pragma
			给编译器的要求
			头文件保护
				#pragma once （简单的头文件保护）
				// 这里下面就可以正常写内容了
			用#pragma控制编译器警告
				#pragma GCC diagnostic ignored "-Wunused-variable"
				// 告诉GCC编译器 忽略变量未使用警告
			但是#pragma不是C语言标准去规定的 但现在大部分常用编译器都支持
			（GCC 、VS）要是代码要在小众编译器跑 最好使用#ifndef
		泛型选择（_Generic）
			指那些没有特定类型 但是一旦指定一种类型 就可以转换成指定类型的代码
			简单说 写代码时先不固定类型 用的时候在指定类型 让代码更通用
			语法结构
				_Generic(控制表达式,类型1:值1,类型2,值2)
			基础语法使用
				_Generic(x,int:0,float:1,double:2)
			结合宏定义
				#define MYTYPE(X) _Generic((x),\
					int: "int", \
					float: "float", \
					default: "未知类型", \
				)
				宏定义引用
					int a = 5;
					printf("a 的类型是 %s",MYTYPE(a));
				展开后是
					_Generic((a), int: "int", float: "float", double: "double", default: "other")
			规则：必须精确匹配 如 const int 使用int是识别不出来的 必须加const
			不支持类型别名 typedef int MyInt; 不会匹配MyInt 因为不认识别名
				MYTYPE(MyInt) // 无法使用
			default分支
				没有匹配到任何结果就执行这里面的
		内联函数（C99）
			内联函数 是通过 inline 声明
			建议编译器在调用处直接嵌入函数体代码以减少调用开销的函数
			需定义与调用同文件 常配合 static 实现内部链接
			编译器可选择优化替换 是宏的类型安全替代方案
			如果不使用static就会是外部链接 且同时存在外部定义
			程序会优先执行外部定义
			C语言内联函数（inline）通过编译期嵌入函数体减少调用开销
			需同文件定义调用，是类型安全的宏替代方案
			inline static int sum(int a,int b) {
				return a+b;
			}
		_Noreturn函数（C11）
			不返回主调函数
			_Noreturn inline static int sum(int a,int b) {
				printf("%d\n",a+b);
				exit(0);
			}
			调用这个函数后程序不会再执行主调函数
	数学库 math.h
		double acos(double x) 返回余弦值为x的角度（0~π弧度） 
		double asin(double x) 返回正弦值为x的角度（-π/2~π/2弧度） 
		double atan(double x) 返回正切值为x的角度（-π/2~π/2弧度） 
		double atan2(double y, double x) 返回正切值为y/x的角度（-π~π弧度） 
		double cos(double x) 返回x的余弦值，x的单位为弧度 
		double sin(double x) 返回x的正弦值，x的单位为弧度 
		double tan(double x) 返回x的正切值，x的单位为弧度 
		double exp(double x) 返回x的指数函数的值（e^x） 
		double log(double x) 返回x的自然对数值 
		double log10(double x) 返回x的以10为底的对数值 
		double pow(double x, double y) 返回x的y次幂 
		double sqrt(double x) 返回x的平方根 
		double cbrt(double x) 返回x的立方根 
		double ceil(double x) 返回不小于x的最小整数值 
		double fabs(double x) 返回x的绝对值 
		double floor(double x) 返回不大于x的最大整数值
		类型变体
			sqrtf sqrt的float版本
			sqrtl sqrt的long double版本
	通用工具库
		stdlib.h
		exit() 和 atexit()
			atexit() 用于注册程序退出时执行的函数
			（可注册多个 调用 exit() 时按逆序执行 无显式 exit() 时 main() 结束也会隐式调用 ）
			exit() 执行 atexit() 注册函数后做清理并终止程序 返回状态 二者协同用于程序退出相关流程控制
		qsort()
			qsort 是 C 标准库中基于快速排序算法 通过自定义比较函数 
			实现对任意类型数组排序的函数 
			需指定数组首地址、元素数量、元素大小及比较逻辑
			#include <stdio.h>
			#include <stdlib.h> // 包含 qsort
			// 比较函数
			int mycomp(const void *p1, const void *p2) {
			    const double *a1 = (const double *)p1;
			    const double *a2 = (const double *)p2;
			    if (*a1 < *a2) return -1;
			    else if (*a1 == *a2) return 0;
			    else return 1;
			}
			int main() {
			    double vals[] = {3.14, 1.59, 2.65, 0.58, 9.79};
			    int n = sizeof(vals) / sizeof(vals[0]); // 计算元素数量
			    
			    // 调用 qsort 排序
			    qsort(vals, n, sizeof(double), mycomp); 
			    
			    // 遍历输出排序后结果
			    for (int i = 0; i < n; i++) {
			        printf("%.2f ", vals[i]); 
			    }
			    return 0;
			}
		mycomp()